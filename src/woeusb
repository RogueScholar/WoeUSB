#!/usr/bin/env bash
# SPDX-FileCopyrightText: © 2013 Colin Gille (congelli501)
# SPDX-FileCopyrightText: © 2018 slacka, et. al.
#
# SPDX-License-Identifier: GPL-3.0-or-later
#
# A Linux program to create bootable Windows USB media from a Windows DVD/ISO
#
# This file is part of WoeUSB.
#
# We use indirections and primitive variables, a false positive of this rule:
# shellcheck disable=SC2034

## Makes debuggers' life easier - Unofficial Bash Strict Mode
set -o errexit -o errtrace -o nounset -o pipefail

## Enable aliases for easy access to functions
shopt -s expand_aliases

for critical_command in realpath basename dirname mktemp; do
  if ! command -v "${critical_command}" &>/dev/null; then
    echo 'Fatal: WoeUSB requires GNU Coreutils in the executable search path.'
    exit 1
  fi
done

## Non-overridable Primitive Variables
if [ -v 'BASH_SOURCE[0]' ]; then
  RUNTIME_EXECUTABLE_PATH="$(realpath -Leqs "${BASH_SOURCE[0]}")"
  RUNTIME_EXECUTABLE_FILENAME="$(basename "${RUNTIME_EXECUTABLE_PATH}")"
  RUNTIME_EXECUTABLE_NAME="${RUNTIME_EXECUTABLE_FILENAME%.*}"
  RUNTIME_EXECUTABLE_DIRECTORY="$(dirname "${RUNTIME_EXECUTABLE_PATH}")"
  RUNTIME_COMMANDLINE_BASECOMMAND="${0}"
  # Keep these partially unused variables declared
  # shellcheck disable=SC2034
  typeset -r RUNTIME_EXECUTABLE_PATH RUNTIME_EXECUTABLE_FILENAME \
    RUNTIME_EXECUTABLE_NAME RUNTIME_EXECUTABLE_DIRECTORY \
    RUNTIME_COMMANDLINE_BASECOMMAND
fi
typeset -ar RUNTIME_COMMANDLINE_PARAMETERS=(${@})

## Global Parameters
## Only set parameters global when there's no other way (like passing in function
## as a function argument), usually when the variable is directly or indirectly
## referenced by traps. Even when the parameter is set global, you should pass it
## in as function argument when it's possible for better code reusability.
## TODO: Global parameter cleanup

### Doing GUI-specific stuff when set to `true`, set by --only-for-gui
### Requires to be set to global due to indirectly referenced by trap
typeset -g global_only_for_gui=false

### Increase verboseness, provide more information when required
typeset -g verbose=false

### Disable message coloring when set to `true`, set by --no-color
typeset -g no_color=false

typeset -gir DD_BLOCK_SIZE="((4 * 1024 * 1024))" # 4MiB

## NOTE: Need to pass to traps, so need to be global
typeset -g source_fs_mountpoint target_fs_mountpoint target_device

## FIXME: No documentation for this non-trivial parameter
typeset -gi pulse_current_pid="0"

## Execution state for cleanup functions to determine if clean up is required
## VALUE: Dash-seperated, lowercased words, no quoting
## NOTE: Need to pass to traps, so need to be global
typeset -g current_state=pre-init

## Supported filesystems
## An associated array with filesystem identifier as key and description as value
typeset -A ENUM_SUPPORTED_FILESYSTEMS=(
  [FS_FAT]='File Allocation Table (FAT)'
  [FS_NTFS]='New Technology File System (NTFS)'
)

## For some reason alias won't be recognized in function if it's definition's
## LINENO is greater then it's reference in function, so we define it here:
alias echo_with_color=util_echo_with_color \
  switch_terminal_text_color=util_switch_terminal_text_color \
  shift_array=util_shift_array \
  is_target_busy=check_is_target_device_busy \
  printf_with_color=util_printf_with_color

## COMPATIBILITY: Use short option for Slackware 14.2
## -d: --directory, -t: --tmpdir
typeset -r temp_directory="$(mktemp -d -t WoeUSB.XXXXXX.tempdir)"

## Entry point of the main code
init() {
  util_check_function_parameters_quantity 2 ${#}
  typeset -r runtime_name="${1}"; shift
  typeset -n only_for_gui_ref="${1}"

  typeset -r app_name="WoeUSB"
  typeset -r app_version="@@WOEUSB_VERSION@@"

  typeset -r DEFAULT_NEW_FS_LABEL='Windows USB'

  current_state=enter-init

  typeset flag_print_help=false flag_print_version=false flag_print_about=false

  typeset -r app_url='https://github.com/slacka/WoeUSB' \
    app_copyright="© 2013 Colin Gille (congelli501)\\n© 2017 slacka, et.al." \
    app_notice="Licensed under the GNU General Public License 3.0"
  typeset install_mode

  # source_media may be a optical disk drive or a disk image
  # target_media may be an entire usb storage device or just a partition
  typeset source_media target_media

  typeset target_partition

  typeset workaround_bios_boot_flag=false

  typeset target_filesystem_type=FS_FAT

  source_fs_mountpoint="/media/woeusb_source_$(date '+%s')_${$}"
  target_fs_mountpoint="/media/woeusb_target_$(date '+%s')_${$}"

  # Parameters that need TBD at runtime due to different names in distributions
  typeset command_mkdosfs command_mkntfs command_grubinstall name_grub_prefix

  typeset new_file_system_label="${DEFAULT_NEW_FS_LABEL}"

  if ! check_runtime_dependencies "${app_name}" command_mkdosfs command_mkntfs \
  command_grubinstall name_grub_prefix; then
    exit 1
  fi

  if ! process_commandline_parameters app_name flag_print_help \
  flag_print_version flag_print_about install_mode source_media target_media \
  new_file_system_label workaround_bios_boot_flag target_filesystem_type \
  global_only_for_gui; then
    print_help "${app_name} ${app_version} ${runtime_name}"
    exit 1
  fi

  process_miscellaneous_requests "${flag_print_help}" "${flag_print_version}" \
    "${flag_print_about}" "${app_name}" "${app_version}" "${app_url}" \
    "${app_copyright}" "${app_notice}" "${runtime_name}"

  printf -- '%s\n%s\n' "${app_name} v${app_version}"

  check_permission "${app_name}"

  if ! check_runtime_parameters install_mode source_media target_media \
  "${new_file_system_label}"; then
    print_help "${app_name} ${app_version} ${runtime_name}"
    exit 1
  fi

  # FIXME: Why `trigger_wxGenericProgressDialog_pulse on` here?
  trigger_wxGenericProgressDialog_pulse on "${only_for_gui_ref}"

  determine_target_parameters "${install_mode}" "${target_media}" target_device \
    target_partition target_filesystem_type

  check_source_and_target_not_busy "${install_mode}" "${source_media}" \
    "${target_device}" "${target_partition}"

  current_state=mount-source-filesystem

  if ! mount_source_filesystem "${source_media}" "${source_fs_mountpoint}"; then
    echo_with_color red 'Error: Unable to mount source filesystem.'
    exit 1
  fi

  if [ "${target_filesystem_type}" == FS_FAT ]; then
    if ! check_fat32_filesize_limitation "${source_fs_mountpoint}"; then
      exit 1
    fi
  fi

  if [ "${install_mode}" = device ]; then
    wipe_existing_partition_table_and_filesystem_signatures "${target_device}"
    create_target_partition_table "${target_device}" legacy
    create_target_partition "${target_partition}" "${target_filesystem_type}" \
      "${new_file_system_label}" "${command_mkdosfs}" "${command_mkntfs}"

    if [ "${target_filesystem_type}" == FS_NTFS ]; then
      create_uefi_ntfs_support_partition "${target_device}"
      install_uefi_ntfs_support_partition "${target_device}2" \
        "${temp_directory}" "${target_device}"
    fi
  fi

  if [ "${install_mode}" = partition ]; then
    check_target_partition "${target_partition}" "${install_mode}" \
      "${target_device}"
  fi

  current_state=mount-target-filesystem

  if ! mount_target_filesystem "${target_partition}" "${target_fs_mountpoint}" \
  "${target_filesystem_type}"; then
    echo_with_color red 'Error: Unable to mount target filesystem.'
    exit 1
  fi

  check_target_filesystem_free_space "${target_fs_mountpoint}" \
    "${source_fs_mountpoint}" || exit 1

  current_state=copying-filesystem

  workaround_linux_make_writeback_buffering_not_suck apply

  copy_filesystem_files "${source_fs_mountpoint}" "${target_fs_mountpoint}" \
    "${only_for_gui_ref}"

  workaround_support_windows_7_uefi_boot "${source_fs_mountpoint}" \
    "${target_fs_mountpoint}"

  install_legacy_pc_bootloader_grub "${target_fs_mountpoint}" \
    "${target_device}" "${command_grubinstall}"

  install_legacy_pc_bootloader_grub_config "${target_fs_mountpoint}" \
    "${name_grub_prefix}"

  if [ "$workaround_bios_boot_flag" == true ]; then
    workaround_systems_that_ignore_disks_without_boot_flag_toggled \
      "$target_device"
  fi

  current_state=finished

  trigger_wxGenericProgressDialog_pulse off "${only_for_gui_ref}"

  exit 0
}; typeset -fr init

print_help() {
  util_check_function_parameters_quantity 3 "${#}"

  typeset -r app_name="${1}"; shift
  typeset -r app_version="${1}"; shift
  typeset -r runtime_name="${1}"

  set +o xtrace
  echo "${app_name} ${app_version} Help Information"
  echo "========================================================================"
  echo -n "${app_name} can create bootable Microsoft Windows® USB media from an "
  echo -e 'existing Windows installation disc or ISO disc image.\n'
  echo -e 'Currently two creation methods are supported:\n'
  echo -e '\t-d, --device\n'
  echo -ne '\t\tCompletely ERASE the entire USB storage device, then build a '
  echo -e 'bootable Windows USB device from scratch.\n'
  echo -e '\t\tWARNING: All existing contents of the device will be gone!\n'
  echo -e "\\t\\t${runtime_name} --device <source path> <device>"
  echo -e '\t\tExamples:'
  echo -e "\\t\\t- ${runtime_name} --device Windows7_x64.iso /dev/sdX"
  echo -e "\\t\\t- ${runtime_name} --device /dev/cdrom0 /dev/sdX\\n"
  echo -e '\t-p, --partition\n'
  echo -ne '\t\tCopy Windows files to an existing partition of a USB storage '
  echo -e 'device and make it bootable.'
  echo -ne '\t\tWARNING: All files that have the same name as those on the disc '
  echo -e 'or image will be overwritten!\n'
  echo -e "\\t\\t${runtime_name} --partition <source path> <partition>"
  echo -e '\t\tExamples:'
  echo -e "\\t\\t- ${runtime_name} --partition Windows7_x64.iso /dev/sdxX"
  echo -e "\\t\\t- ${runtime_name} --partition /dev/cdrom0 /dev/sdxX\\n"
  echo -e '## -- Command Line Options -- ##'
  echo -e '\t-v, --verbose\n\t\tVerbose mode\n'
  echo -e '\t-h, --help\n\t\tShow this help message and exit\n'
  echo -e '\t-V, --version\n\t\tPrint application version\n'
  echo -e '\t-ab, --about\n\t\tShow information about this application\n'
  echo -e '\t--no-color\n\t\tDisable output message coloring\n'
  echo -e '\t--debug\n\t\tEnable application debugging\n'
  echo -e '\t-l, --label <filesystem label>'
  echo -e '\t\tSpecify the label for the new file system in --device mode'
  echo -e '\t\tNote: Be sure the label is valid for the chosen filesystem.\n'
  echo -e '\t--workaround-bios-boot-flag'
  echo -ne '\tWorkaround a BIOS bug that won't include the device in boot menu '
  echo -e 'if the partition's boot flag is set\n'
  echo -e '\t--debug-function <function name> [argument]...'
  echo -e '\t\tOption to test a function without running the entire app\n'
  echo -e '\t--tgt-fs, --target-filesystem <filesystem>'
  echo -e '\t\tSpecify the filesystem to use for the target partition'
  echo -e '\t\tCurrently supported: FAT (default) / NTFS\n'
}; typeset -fr print_help

## Print application version then exit, for debugging purpose.
print_version() {
  util_check_function_parameters_quantity 1 "${#}"

  typeset -r app_version="${1}"

  printf -- '%s\n' "${app_version}"
}; typeset -fr print_version

print_application_info() {
  util_check_function_parameters_quantity 5 "${#}"
  typeset -r app_name="${1}"; shift
  typeset -r app_version="${1}"; shift
  typeset -r app_url="${1}"; shift
  typeset -r app_copyright="${1}"; shift
  typeset -r app_notice="${1}"

  echo -e "\\t${app_name} v${app_version}\\n\\t${app_url}\\n\\t${app_copyright}"
  echo -e "\\t${app_notice}"

}; typeset -fr print_application_info

process_commandline_parameters() {
  util_check_function_parameters_quantity 11 "${#}"
  typeset -r app_name="${1}"; shift
  typeset -n flag_print_help_ref="${1}"; shift
  typeset -n flag_print_version_ref="${1}"; shift
  typeset -n flag_print_about_ref="${1}"; shift
  typeset -n install_mode_ref="${1}"; shift
  typeset -n source_media_ref="${1}"; shift
  typeset -n target_media_ref="${1}"; shift
  typeset -n new_file_system_label_ref="${1}"; shift
  typeset -n workaround_bios_boot_flag_ref="${1}"; shift
  typeset -n target_filesystem_type_ref="${1}"; shift
  typeset -n only_for_gui_ref="${1}"

  if [ "${#RUNTIME_COMMANDLINE_PARAMETERS[@]}" -eq 0 ]; then
    flag_print_help_ref=true
    return 0
  fi

  typeset -a parameters=(${RUNTIME_COMMANDLINE_PARAMETERS[@]})
  typeset enable_debug=false enable_device=false enable_partition=false \
    enable_label=false enable_workaround_bios_boot_flag=false \
    enable_debugging_internal_function_call=false enable_target_filesystem=false

  # Inputs that requires sanitation
  typeset target_filesystem_type_input

  while [ "${#parameters[@]}" -ne 0 ]; do
    case "${parameters[0]}" in
      -p | --partition)
        enable_partition=true
        install_mode_ref=partition
        shift_array parameters
        if [ "${#parameters[@]}" -lt 2 ]; then
          echo_with_color red \
            "${FUNCNAME[0]}: Error: --partition option requires 2 arguments!"
          return 1
        fi
        source_media_ref="${parameters[0]}"
        shift_array parameters
        target_media_ref="${parameters[0]}"
        ;;
      -d | --device)
        enable_device=true
        # Limitation of ShellCheck to detect usage of indirection variables
        # shellcheck disable=SC2034
        install_mode_ref=device
        shift_array parameters
        if [ "${#parameters[@]}" -lt 2 ]; then
          echo_with_color red \
            "${FUNCNAME[0]}: Error: --device option requires 2 arguments!"
          return 1
        fi
        source_media_ref="${parameters[0]}"
        shift_array parameters
        target_media_ref="${parameters[0]}"
        ;;
      -l | --label)
        enable_label=true
        shift_array parameters
        if [ ${#parameters[@]} -lt 1 ]; then
          printf_with_color red '%s: %s\n' "${FUNCNAME[0]}" \
            'ERROR: --label option requires 1 argument.'
          return 1
        fi
        new_file_system_label_ref="${parameters[0]}"
        ;;
      --tgt-fs | --target-filesystem)
        enable_target_filesystem=true
        shift_array parameters
        if [ ${#parameters[@]} -lt 1 ]; then
          printf_with_color red '%s: %s\n' "${FUNCNAME[0]}" \
            'ERROR: --target-filesystem option requires 1 argument.'
          return 1
        fi
        # Normalize subshell command output to uppercase
        target_filesystem_type_input="$(tr '[:lower:]' '[:upper:]' \
          <<< "${parameters[0]}")"
        ;;
      -v | --verbose)
        verbose=true
        ;;
      -h | --help)
        flag_print_help_ref=true
        return 0
        ;;
      -V | --version)
        flag_print_version_ref=true
        return 0
        ;;
      -ab | --about)
        flag_print_about_ref=true
        return 0
        ;;
      --debug)
        enable_debug=true
        ;;
      --debug-function)
        enable_debugging_internal_function_call=true
        shift_array parameters
        if [ ${#parameters[@]} -lt 1 ]; then
          printf_with_color red '%s: %s\n' "${FUNCNAME[0]}" \
            'ERROR: --debug-function option requires at least 1 argument.'
          return 1
        fi
        "${parameters[@]}"
        exit "${?}"
        ;;
      --for-gui)
        no_color=true
        only_for_gui_ref=true
        ;;
      --no-color)
        no_color=true
        ;;
      --workaround-bios-boot-flag)
        enable_workaround_bios_boot_flag=true
        workaround_bios_boot_flag_ref=true
        ;;
      *)
        echo_with_color red \
          "ERROR: Unknown command-line argument \"${parameters[0]}\"" >&2
        return 1
        ;;
    esac
    shift_array parameters
  done

  # No action mode is specified
  if [ "${enable_device}" == false ] && [ "${enable_partition}" == false ] && \
  [ "${enable_debugging_internal_function_call}" == false ]; then
    # Intentionally not mentioning the function debugging option
    echo_with_color red "${FUNCNAME[0]}: Error: No mode option specified!" >&2
    return 1
  elif [ "${enable_device}" == true ] && [ "${enable_partition}" == true ]; then
    echo_with_color red \
      "${FUNCNAME[0]}: Error: -d and -p options are mutually exclusive." >&2
    return 1
  fi

  # --label option not used with --device mode
  if [ "${enable_partition}" == true ] && [ "${enable_label}" == true ]; then
    echo_with_color red "${FUNCNAME[0]}: Error: -l can only be used with -d"
    return 1
  fi

  ## --target-filesystem option is not use with --partition creation method
  if [ "${enable_target_filesystem}" == true ] &&
  [ "${enable_partition}" == true ]; then
    echo_with_color red \
      "${FUNCNAME[0]}: Error: --tgt-fs option can only be used with -d"
    return 1
  fi

  ## Argument check for --target-filesystem
  if [ "${enable_target_filesystem}" = true ]; then
    case "${target_filesystem_type_input}" in
      FAT)
        target_filesystem_type_ref=FS_FAT
        ;;
      NTFS)
        target_filesystem_type_ref=FS_NTFS
        ;;
      *)
        printf -- '%s: Error: Target filesystem not supported.\n' \
          "${FUNCNAME[0]}" >&2
        return 1
        ;;
    esac
  fi

  if [ "${verbose}" = true ] && [ "${enable_debug}" != true ]; then
    trap 'trap_return "${FUNCNAME[0]}"' RETURN

    # Disabled due to FIXME
    # trap 'trap_debug "${BASH_COMMAND}"' DEBUG
  fi

  # Always be the last condition so that less debug messages will be printed
  if [ "${enable_debug}" = true ]; then
    set -o xtrace
  fi

  return 0
}; typeset -fr process_commandline_parameters

process_miscellaneous_requests() {
  util_check_function_parameters_quantity 9 "${#}"
  typeset -r flag_print_help="${1}"; shift
  typeset -r flag_print_version="${1}"; shift
  typeset -r flag_print_about="${1}"; shift
  typeset -r app_name="${1}"; shift
  typeset -r app_version="${1}"; shift
  typeset -r app_url="${1}"; shift
  typeset -r app_copyright="${1}"; shift
  typeset -r app_notice="${1}"; shift
  typeset -r runtime_name="${1}"; shift

  if [ "${flag_print_help}" == true ]; then
    print_help "${app_name}" "v${app_version} "${runtime_name}"
    exit 0
  fi

  if [ "${flag_print_version}" == true ]; then
    print_version "v${app_version}"
    exit 0
  fi

  if [ "${flag_print_about}" == true ]; then
    print_application_info "${app_name}" "v${app_version}" "${app_url}" \
      "${app_copyright}" "${app_notice}"
    exit 0
  fi

}; typeset -fr process_miscellaneous_requests

check_runtime_dependencies() {
  util_check_function_parameters_quantity 5 "${#}"
  typeset -r app_name="$1"; shift
  typeset -n command_mkdosfs_ref="$1"; shift
  typeset -n command_mkntfs_ref="$1"; shift
  typeset -n command_grubinstall_ref="$1"; shift
  typeset -n name_grub_prefix_ref="$1"

  typeset result=unknown

  for required_command in awk blockdev dd df du find grep id lsblk mkdir mktemp \
  mount parted partprobe readlink rm stat wget wipefs; do
    if ! command -v "${required_command}" &>/dev/null; then
      echo_with_color red \
        "${FUNCNAME[0]}: Error: ${required_command} command not found."
      result=failed
    fi
  done; unset required_command

  if command -v mkdosfs &>/dev/null; then
    command_mkdosfs_ref=mkdosfs
  elif command -v mkfs.msdos &>/dev/null; then
    command_mkdosfs_ref=mkfs.msdos
  elif command -v mkfs.vfat &>/dev/null; then
    command_mkdosfs_ref=mkfs.vfat
  elif command -v mkfs.fat &>/dev/null; then
    command_mkdosfs_ref=mkfs.fat
  else
    printf_with_color red '%s\n%s\n' \
      "${FUNCNAME[0]}: Error: mkdosfs/mkfs.fs command not found!" \
      "${FUNCNAME[0]}: Please make sure that dosfstools is installed." >&2
    result='failed'
  fi

  if command -v mkntfs &>/dev/null; then
    command_mkntfs_ref=mkntfs
  else
    printf_with_color red '%s\n%s\n' \
      "${FUNCNAME[0]}: Error: mkntfs command not found!" \
      "${FUNCNAME[0]}: Error: Please make sure that ntfs-3g is installed." >&2
    result=failed
  fi

  if command -v grub-install.unsupported &>/dev/null; then
    command_grubinstall_ref=grub-install.unsupported
    name_grub_prefix_ref=grub
  elif command -v grub-install &>/dev/null; then
    command_grubinstall_ref=grub-install
    name_grub_prefix_ref=grub
  elif command -v grub2-install &>/dev/null; then
    command_grubinstall_ref=grub2-install
    name_grub_prefix_ref=grub2
  else
    printf_with_color red '%s\n%s\n' \
      "${FUNCNAME[0]}: Error: grub-install or grub2-install command not found!" \
      "${FUNCNAME[0]}: Error: Please make sure that GNU GRUB is installed." >&2
    result=failed
  fi

  if [ "${result}" == failed ]; then
    return 1
  else
    return 0
  fi
}; typeset -fr check_runtime_dependencies

check_permission() {
  util_check_function_parameters_quantity 1 "${#}"
  typeset -r app_name="$1"

  if [ "$(id -u)" -ne 0 ]; then
    printf_with_color yellow '%s\n%s\n' \
      "Warning: You are not running ${app_name} as root!" \
      'Warning: This might be the reason for the current failure.' >&2
  fi
  return 0
}; typeset -fr check_permission

check_runtime_parameters() {
  util_check_function_parameters_quantity 4 "${#}"
  typeset -n install_mode_ref="${1}"; shift
  typeset -n source_media_ref="${1}"; shift
  typeset -n target_media_ref="${1}"

  if [ ! -f "${source_media_ref}" ] && [ ! -b "${source_media_ref}" ]; then
    printf_with_color red '%s%s\n' \
      "${FUNCNAME[0]}: Error: Source \"${source_media_ref}\" not found or not " \
      "a file or block device!" >&2
    return 1
  fi

  if ! [ -b "${target_media_ref}" ]; then
    printf_with_color red '%s%s\n' \
      "${FUNCNAME[0]}: Error: Target \"${target_media_ref}\" is not a block " \
      "device!" >&2
    return 1
  fi

  if [ "${install_mode_ref}" = device ] && [[ "${target_media}" =~ .*[0-9] ]]
  then
    printf_with_color red '%s%s\n' \
      "${FUNCNAME[0]}: Error: Target \"${target_media_ref}\" is not a storage " \
      "device!" >&2
    return 1
  fi

  if [ "${install_mode_ref}" = partition ] &&
  ! [[ "${target_media}" =~ .*[0-9] ]]; then
    printf_with_color red '%s%s\n' \
      "${FUNCNAME[0]}: Error: Target \"${target_media_ref}\" is not a " \
      "partition!" >&2
    return 1
  fi

  return 0
}; typeset -fr check_runtime_parameters

determine_target_parameters() {
  util_check_function_parameters_quantity 5 "${#}"
  typeset install_mode="${1}"; shift
  typeset target_media="${1}"; shift
  typeset -n target_device_ref="${1}"; shift
  typeset -n target_partition_ref="${1}"; shift
  typeset -n target_filesystem_type_ref="${1}"; shift

  if [ "${install_mode}" = partition ]; then
    typeset target_fs_type_libblkid

    target_partition_ref="${target_media}"
    target_device_ref="${target_media/%[0-9]/}"

    # Detect target filesystem
    target_fs_type_libblkid="$(lsblk -no FSTYPE "${target_partition_ref}")"

    case "${target_fs_type_libblkid}" in
      vfat)
        target_filesystem_type_ref=FS_FAT
        ;;
      ntfs)
        target_filesystem_type_ref=FS_NTFS
        ;;
      *)
        printf -- '%s: Error: Filesystem "%s" unsupported.\n Use %s or %s.' \
          "${FUNCNAME[0]}" "${target_fs_type_libblkid}" \
          "${ENUM_SUPPORTED_FILESYSTEMS[FS_FAT]}" \
          "${ENUM_SUPPORTED_FILESYSTEMS[FS_NTFS]}"
        return 1
        ;;
    esac; unset target_fs_type_libblkid
  else # install_mode = device
    target_device_ref="${target_media}"
    target_partition_ref="${target_device}1"
  fi

  if [ "${verbose}" = true ]; then
    echo "${FUNCNAME[0]}: Info: Target device is ${target_device_ref}"
    echo "${FUNCNAME[0]}: Info: Target partition is ${target_partition_ref}"
    if [ "${install_mode}" = partition ]; then
      echo -n "${FUNCNAME[0]}: Info: Target filesystem is "
      echo "${ENUM_SUPPORTED_FILESYSTEMS[$target_filesystem_type]}"
    fi
  fi
  return 0
}; typeset -fr determine_target_parameters

check_is_target_device_busy() {
  util_check_function_parameters_quantity 1 "${#}"
  typeset device="${1}"

  if [ "$(mount | grep -Fc "${device}")" -ne 0 ]; then
    return 0
  else
    return 1
  fi
}; typeset -fr check_is_target_device_busy

check_source_and_target_not_busy() {
  util_check_function_parameters_quantity 4 "${#}"
  typeset install_mode="${1}"; shift
  typeset source_media="${1}"; shift
  typeset target_device="${1}"; shift
  typeset target_partition="${1}"

  if [ "$(mount | grep -Fc "${source_media}")" -ne 0 ]; then
    echo_with_color red \
      "Error: Source is currently mounted; unmount then try again." >&2
    exit 1
  fi

  if [ "${install_mode}" = partition ]; then
    if [ "$(mount | grep -Fc "${target_partition}")" -ne 0 ]; then
      echo_with_color red \
        "Error: Target partition is mounted, unmount it then try again." >&2
      exit 1
    fi
  else # When install_mode = device, all target partitions needs to be unmounted
    if is_target_busy "${target_device}"; then
      echo_with_color red \
        "Error: Target device is busy, unmount it then try again." >&2
      exit 1
    fi
  fi
}; typeset -fr check_source_and_target_not_busy

wipe_existing_partition_table_and_filesystem_signatures() {
  util_check_function_parameters_quantity 1 "${#}"
  typeset -r target_device="${1}"

  echo_with_color green \
    "Wiping existing partition table and filesystems on ${target_device}..."
  wipefs --all "${target_device}"

  check_if_the_drive_is_really_wiped "${target_device}"

  return $?
}; typeset -fr wipe_existing_partition_table_and_filesystem_signatures

## Some broken flash drives will appear to be successfully wiped but actually
## nothing is written to it and it will show previous partition scheme. This is
## the detection of the case and will bail out if so.
check_if_the_drive_is_really_wiped() {
  util_check_function_parameters_quantity 1 "${#}"
  typeset -r target_device="${1}"

  printf_with_color green 'Checking that %s is empty...\n' "${target_device}"

  if "$(env LANG=C lsblk -no TYPE "${target_device}" | grep -Fc part)"; then
    printf_with_color red \
      'Error: %s: Unable to wipe %s, check if it is locked or has failed.\n' \
      "${FUNCNAME[0]}" "${target_device}"
    return 1
  else
    return 0
  fi
}; typeset -fr check_if_the_drive_is_really_wiped

create_target_partition_table() {
  util_check_function_parameters_quantity 2 "${#}"
  typeset -r target_device="${1}"; shift
  typeset -r partition_table_type="${1}"

  echo_with_color green "Creating new partition table on ${target_device}..."

  typeset parted_partiton_table_argument

  case "$partition_table_type" in
    legacy | msdos | mbr | pc)
      parted_partiton_table_argument=msdos
      ;;
    gpt | guid)
      parted_partiton_table_argument=gpt
      echo_with_color red \
        "${FUNCNAME[0]}: Error: GUID partition tables not supported."
      return 2
      ;;
    *)
      echo_with_color red \
        "${FUNCNAME[0]}: Error: Partition table not supported."
      return 2
      ;;
  esac

  # Create partition table(and overwrite the old one, whatever it was)
  parted -s "${target_device}" mklabel "$parted_partiton_table_argument"
}; typeset -fr create_target_partition_table

# NOTE: This should be done automatically by GNU Parted after every operation
workaround_make_system_realize_partition_table_changed() {
  util_check_function_parameters_quantity 1 "${#}"
  typeset -r target_device="${1}"

  printf_with_color green '%s\n' \
    "Triggering rescan of new partition table on ${target_device}..."

  blockdev --rereadpt "${target_device}" || true
  echo 'Waiting for block device nodes to populate...'
  sleep 3
}; typeset -fr workaround_make_system_realize_partition_table_changed

create_target_partition() {
  util_check_function_parameters_quantity 5 "${#}"
  typeset -r target_partition="${1}"; shift

  # ENUM_SUPPORTED_FILESYSTEMS
  typeset -r filesystem_type="${1}"; shift

  typeset -r filesystem_label="${1}"; shift
  typeset -r command_mkdosfs="${1}"; shift
  typeset -r command_mkntfs="${1}"

  typeset parted_mkpart_fs_type
  case "${filesystem_type}" in
    FS_FAT)
      parted_mkpart_fs_type=fat32
      ;;
    FS_NTFS)
      parted_mkpart_fs_type=ntfs
      ;;
    *)
      echo_with_color red "${FUNCNAME[0]}: Error: Filesystem not supported."
      return 2
      ;;
  esac

  printf_with_color green '%s\n' 'Creating target partition...'

  # Create target partition
  # We start at 4MiB for grub (it needs a post-MBR gap for its code) and
  # alignment of flash memory block erase segment in general. If NTFS is used we
  # leave a 512KiB partition at the end for installing EFI partition.
  case "${parted_mkpart_fs_type}" in
    fat32)
      parted -s "${target_device}" mkpart primary "${parted_mkpart_fs_type}" \
        4MiB -- -1s # last sector of the disk
      ;;
    ntfs)
      # Major partition for storing user files
      # NOTE: Windows used to only recognize the first partition on removable
      # storage devices, that's why this partition should always be first.
      parted -s "${target_device}" mkpart primary "${parted_mkpart_fs_type}" \
        4MiB -- -1025s # Leave 512KiB (1024 sectors @ usual 512b/sector)
      # FIXME: Leaving exactly 512KiB in all circumstances is better
      ;;
    *)
      printf_with_color red '%s\n' \
        "${FUNCNAME[0]}: FATAL: Unsupported partition type, please report bug."
      ;;
  esac
  unset parted_mkpart_fs_type

  workaround_make_system_realize_partition_table_changed "${target_device}"

  # Format target partition's filesystem
  case "${filesystem_type}" in
    FS_FAT)
      "${command_mkdosfs}" -F 32 -n "${filesystem_label}" "${target_partition}"
      ;;
    FS_NTFS)
      "${command_mkntfs}" -QL "${filesystem_label}" "${target_partition}"
      ;;
    *)
      echo_with_color red "${FUNCNAME[0]}: FATAL: Unsupported partition type."
      exit 1
      ;;
  esac
}; typeset -fr create_target_partition

## Create EFI partition to support booting NTFS filesystem which some UEFI
## firmwares are not able to do.
## https://github.com/pbatard/uefi-ntfs
## This routine assumes that there's only one partition on the drive and the
## trailing 512KiB space is not partitioned. This routine should be run after
## create_target_partition and only if target partition's filesystem is NTFS.
create_uefi_ntfs_support_partition() {
  util_check_function_parameters_quantity 1 "${#}"

  typeset -r target_device="${1}"

  # FIXME: The partition type should be fat12 but that isn't recognized by Parted
  # NOTE: The alignment is set to none because this partition is misaligned but
  # ignored due to it's small size.
  parted -a none -s "${target_device}" mkpart primary fat16 -- -1024s -1s

  return "${?}"
}; typeset -fr create_uefi_ntfs_support_partition

## Install EFI partition by writing downloaded partition image
## FIXME: This requires internet access to download the image from GitHub.
## It should be replaced by including the image in our datadir.
install_uefi_ntfs_support_partition() {
  util_check_function_parameters_quantity 3 "${#}"

  typeset -r uefi_ntfs_partition="${1}"; shift
  typeset -r download_directory="${1}"; shift
  typeset -r target_device="${1}"

  if ! wget -P "${download_directory}" \
  https://github.com/pbatard/rufus/raw/master/res/uefi/uefi-ntfs.img; then
    printf_with_color yellow '%s: %s\n%s\n' "${FUNCNAME[0]}" \
      "Warning: Unable to download EFI partition image, installation skipped."
      "Device might not be bootable if the UEFI firmware doesn't support NTFS."
    return 0
  fi

  # Write partition image to partition
  dd if="${download_directory}/uefi-ntfs.img" of="${uefi_ntfs_partition}"
}; typeset -fr install_uefi_ntfs_support_partition

## Some BIOSes won't list devices with valid MBR but no partitions with the boot
## flag set into the boot menu. Overcome this by setting the first partition's
## boot flag (which doesn't matter as GNU GRUB doesn't depend on it anyway).
workaround_systems_that_ignore_disks_without_boot_flag_toggled() {
  util_check_function_parameters_quantity 1 "${#}"

  typeset -r target_device="${1}"

  printf_with_color yellow '%s%s\n' \
    'Applying workaround for systems that ignore disks with no partitions ' \
    'with the boot flag set...'
  parted -s "${target_device}" set 1 boot on

  return "${?}"
}; typeset -fr workaround_systems_that_ignore_disks_without_boot_flag_toggled

## Check files in source for any larger than FAT32 max. file size (~4GiB)
check_fat32_filesize_limitation() {
  util_check_function_parameters_quantity 1 "${#}"
  typeset -r source_fs_mountpoint="${1}"

  while IFS= read -r -d '' file; do
    if (("$(stat -c '%s' "$file")" > 4294967295)); then # Max fat32 file size is 2^32 - 1 bytes
      if [[ "${file}" == */install.wim ]]; then
        printf_with_color \
          yellow \
          'Detected large "install.wim", will try to split it in multiple chunks\n'
        continue
      fi
      printf_with_color \
        red \
        'Error: File "%s" in source image has exceed the FAT32 Filesystem 4GiB Single File Size Limitation and cannot be installed.  You must specify a different --target-filesystem.\n' \
        "$file"
      printf_with_color \
        red \
        'Refer: https://github.com/slacka/WoeUSB/wiki/Limitations#fat32-filesystem-4gib-single-file-size-limitation for more info.\n'
      return 1
    fi
  done < <(find "$source_fs_mountpoint" -type f -print0)
  return 0
}
typeset -fr check_fat32_filesize_limitation

## Check target partition for potential problems before mounting them for --partition creation mode as we don't know about the existing partition
## target_partition: The target partition to check
## install_mode: The usb storage creation method to be used
## target_device: The parent device of the target partition, this is passed in to check UEFI:NTFS filesystem's existence on check_uefi_ntfs_support_partition
check_target_partition() {
  util_check_function_parameters_quantity 3 $#
  typeset target_partition="${1}"
  shift
  typeset install_mode="${1}"
  shift
  typeset target_device="${1}"

  typeset target_filesystem
  target_filesystem="$(
    lsblk \
      --output FSTYPE \
      --noheadings \
      "$target_partition"
  )"

  case "$target_filesystem" in
    vfat)
      : # supported
      ;;
    ntfs)
      check_uefi_ntfs_support_partition \
        "$target_device"
      ;;
    *)
      printf_with_color red \
        '%s\n' \
        "${FUNCNAME[0]}: Error: Target filesystem not supported, currently supported filesystem: FAT, NTFS."
      return 1
      ;;
  esac
  return 0
}
typeset -fr check_target_partition

## Check if the UEFI:NTFS support partition exists
## Currently it depends on the fact that this partition has a label of "UEFI_NTFS"
## target_device: The UEFI:NTFS partition residing entier device file
check_uefi_ntfs_support_partition() {
  util_check_function_parameters_quantity 1 $#

  typeset -r target_device="$1"

  if
    ! \
      lsblk \
      --output LABEL \
      --noheadings \
      "$target_device" |
      grep \
        --fixed-strings \
        --silent \
        'UEFI_NTFS'
  then
    printf_with_color yellow \
      '%s: %s\n' \
      "${FUNCNAME[0]}" \
      "Warning: Your device doesn't seems to have an UEFI:NTFS partition, UEFI booting will fail if the motherboard firmware itself doesn't support NTFS filesystem!"
    printf -- \
      '%s: %s\n' \
      "${FUNCNAME[0]}" \
      'Info: You may recreate disk with an UEFI:NTFS partition by using the --device creation method'
  fi
}
typeset -fr check_uefi_ntfs_support_partition

mount_source_filesystem() {
  util_check_function_parameters_quantity 2 $#
  typeset source_media="$1"
  shift
  typeset source_fs_mountpoint="$1"

  echo_with_color green 'Mounting source filesystem...'

  mkdir \
    --parents \
    "$source_fs_mountpoint" ||
    (
      echo_with_color red "${FUNCNAME[0]}: Error: Unable to create \"$source_fs_mountpoint\" mountpoint directory"
      return 1
    )
  if [ -f "$source_media" ]; then # ${source_media} is an ISO image
    mount \
      --options loop,ro \
      --types udf,iso9660 \
      "$source_media" \
      "$source_fs_mountpoint" ||
      (
        echo_with_color red "${FUNCNAME[0]}: Error: Unable to mount source media"
        return 1
      )
  else # ${source_media} is a real optical disk drive (block device)
    mount \
      --options ro \
      "$source_media" \
      "$source_fs_mountpoint" ||
      (
        echo_with_color red "${FUNCNAME[0]}: Error: Unable to mount source media"
        return 1
      )
  fi
}
typeset -fr mount_source_filesystem

# Mount target filesystem to existing path as mountpoint
# target_partition: The partition device file target filesystem resides, for example /dev/sdX1
# target_fs_mountpoint: The existing directory used as the target filesystem's mountpoint, for example /mnt/target_filesystem
# target_fs_type: The filesystem of the target filesystem currently supports: FAT, NTFS
mount_target_filesystem(){
  util_check_function_parameters_quantity 3 $#
  typeset target_partition="$1"; shift
  typeset target_fs_mountpoint="$1"; shift

  # ENUM_SUPPORTED_FILESYSTEMS
  typeset target_fs_type="$1"

  echo_with_color green 'Mounting target filesystem...'

  mkdir \
    --parents \
    "${target_fs_mountpoint}" \
    || (
      echo_with_color red "${FUNCNAME[0]}: Error: Unable to create \"${target_fs_mountpoint}\" mountpoint directory"
      return 1
    )

  # Determine proper mount options according to filesystem type
  typeset mount_options='defaults'
  typeset fstype_options=''

  case "${target_fs_type}" in
    FS_FAT)
      mount_options+=',utf8=1'
      fstype_options="-t vfat"
      ;;
    FS_NTFS)
      fstype_options="-t ntfs-3g"
      ;;
    *)
      printf_with_color \
        red \
        'Fatal: %s: Unsupported target_fs_type, please report bug.\n' \
        "${FUNCNAME[0]}"
      exit 1
      ;;
  esac

  mount \
    --options "${mount_options}" \
    "${fstype_options}" \
    "${target_partition}" \
    "${target_fs_mountpoint}" \
    || (
      echo_with_color red "${FUNCNAME[0]}: Error: Unable to mount target partition"
      return 1
    )
}; typeset -fr mount_target_filesystem

check_target_filesystem_free_space(){
  util_check_function_parameters_quantity 2 $#
  typeset -r target_fs_mountpoint="${1}"; shift
  typeset -r source_fs_mountpoint="${1}"

  free_space=$(
    df \
      --block-size=1 \
      "${target_fs_mountpoint}" |
        grep \
      --fixed-strings \
      "${target_fs_mountpoint}" |
        awk '{print $4}'
  )
  free_space_human_readable=$(
    df \
      --human-readable \
      "${target_fs_mountpoint}" |
        grep \
      --fixed-strings \
      "${target_fs_mountpoint}" |
        awk '{print $4}'
  )
  needed_space=$(
    du \
      --summarize \
      --bytes \
      "${source_fs_mountpoint}" |
        awk '{print $1}'
  )
  needed_space_human_readable=$(
    du \
      --summarize \
      --human-readable \
      "${source_fs_mountpoint}" |
        awk '{print $1}'
  )
  additional_space_required_for_grub_installation="$((1000 * 1000 * 10))" # 10MiB
  ((needed_space = needed_space + additional_space_required_for_grub_installation))

  if [ "${needed_space}" -gt "${free_space}" ]; then
    echo 'Error: Not enough free space on target partition!' >&2
    echo "Error: We required ${needed_space_human_readable}(${needed_space} bytes) but '${target_partition}' only has ${free_space_human_readable}(${free_space} bytes)." >&2
    return 1
  fi
}; typeset -fr check_target_filesystem_free_space

## Copying all files from one filesystem to another, with progress reporting
copy_filesystem_files() {
  util_check_function_parameters_quantity 3 "${#}"
  typeset source_fs_mountpoint="${1}"
  shift
  typeset target_fs_mountpoint="${1}"
  shift
  typeset -r only_for_gui="${1}"

  typeset -i total_size
  total_size=$(
    du \
      --summarize \
      --bytes \
      "$source_fs_mountpoint" |
      awk '{print $1}'
  )

  # FIXME: Why do we `trigger_wxGenericProgressDialog_pulse off` and on here?
  trigger_wxGenericProgressDialog_pulse \
    off \
    "$only_for_gui"

  echo_with_color green 'Copying files from source media...'

  pushd "$source_fs_mountpoint" >/dev/null

  typeset -i copied_size=0 percentage
  while IFS='' read -r -d '' source_file; do
    dest_file="$target_fs_mountpoint/$source_file"

    source_file_size=$(
      stat \
        --format=%s \
        "$source_file"
    )

    if [ -d "$source_file" ]; then
      mkdir --parents "$dest_file"
    elif [ -f "$source_file" ]; then
      if [ "$verbose" = true ]; then
        echo -e "\\nINFO: Copying \"$source_file\"..."
      fi
      if [ "$source_file_size" -gt 4294967295 ] && [[ "${source_file}" == */install.wim ]]; then
        echo -e "\\nSplitting large install.wim image"
        wimsplit "$source_file" "$(echo "$dest_file" | sed 's/install.wim$/install.swm/g')" 3800
      else
        if [ "$source_file_size" -lt "$DD_BLOCK_SIZE" ]; then
          cp "$source_file" "$dest_file"
        else
          copy_large_file \
            "$source_file" \
            "$dest_file" \
            "$copied_size" \
            "$total_size"
        fi
      fi
    else
      echo_with_color red "${FUNCNAME[0]}: Error: Unknown type of '$source_file'!" >&2
      exit 1
    fi

    # Calculate and report progress
    # BASHDOC: Basic Shell Features » Shell Expansions » Arithmetic Expansion
    # BASHDOC: Bash Features » Shell Arithmetic
    ((copied_size = copied_size + source_file_size)) || true
    ((percentage = (copied_size * 100) / total_size)) || true
    echo -en "$percentage%\\r"
  done < <(
    find \
      . \
      -not -path "." \
      -print0
  )
  unset source_file dest_file source_file_size copied_size percentage

  popd >/dev/null

  trigger_wxGenericProgressDialog_pulse \
    on \
    "$only_for_gui"

  return 0
}
typeset -fr copy_filesystem_files

## Companion function of copy_filesystem_files for copying large files
## Copy source_file to dest_file, overwrite file if dest_file exists
## Also report copy_filesystem_files progress during operation
copy_large_file() {
  util_check_function_parameters_quantity 4 "${#}"
  typeset -r source_file="${1}"
  shift
  typeset -r dest_file="${1}"
  shift
  typeset -ir caller_copied_size="${1}"
  shift
  typeset -ir caller_total_size="${1}"

  typeset -i source_file_size
  source_file_size=$(
    stat \
      --format=%s \
      "$source_file"
  )

  # block count of the source file
  typeset -i block_number
  ((block_number = source_file_size / DD_BLOCK_SIZE + 1))
  unset source_file_size

  if [ -f "$dest_file" ]; then
    rm "$dest_file"
  fi

  # Copy file block by block
  typeset -i i=0 copied_size_total percentage
  while [ "$i" -lt "$block_number" ]; do
    dd \
      if="$source_file" \
      bs="$DD_BLOCK_SIZE" \
      skip="$i" \
      seek="$i" \
      of="$dest_file" \
      count=1 \
      2>/dev/null
    ((i = i + 1))

    # Calculate and report progress
    # BASHDOC: Basic Shell Features » Shell Expansions » Arithmetic Expansion
    # BASHDOC: Bash Features » Shell Arithmetic
    ((copied_size_total = caller_copied_size + DD_BLOCK_SIZE * i)) || true
    ((percentage = (copied_size_total * 100) / caller_total_size)) || true
    echo -en "$percentage%\\r"
  done
  unset i copied_size_total percentage

  return 0
}
typeset -fr copy_large_file

## As Windows 7's installation media doesn't place the required EFI
## bootloaders in the right location, we extract them from the
## system image manually
## TODO: Functionize Windows 7 checking
workaround_support_windows_7_uefi_boot() {
  util_check_function_parameters_quantity 2 "${#}"
  typeset source_fs_mountpoint="${1}"
  shift
  typeset target_fs_mountpoint="${1}"

  # Apply workaround only if the source is based on Windows 7, and EFI version of bootmgr is in place
  if ! grep \
    --extended-regexp \
    --quiet \
    '^MinServer=7[0-9]{3}\.[0-9]' \
    "$source_fs_mountpoint/sources/cversion.ini" ||
    ! [ -f "$source_fs_mountpoint/bootmgr.efi" ]; then
    return 0
  fi

  echo_with_color yellow 'Source media seems to be Windows 7-based with EFI support, applying workaround to make it support UEFI booting'
  if ! command -v '7z' >/dev/null 2>&1; then
    echo_with_color yellow "Warning: '7z' utility not found, workaround is not applied." >&2
    return 0
  fi

  # Detect **case-insensitive** existing efi directories according to UEFI spec
  typeset \
    test_efi_directory \
    efi_directory
  test_efi_directory="$(
    find \
      "$target_fs_mountpoint" \
      -ipath "$target_fs_mountpoint/efi"
  )"
  if [ -z "$test_efi_directory" ]; then
    efi_directory="$target_fs_mountpoint/efi"
    if [ "$verbose" = true ]; then
      printf -- \
        "%s: DEBUG: Can't find efi directory, use %s.\\n" \
        "${FUNCNAME[0]}" \
        "$efi_directory"
    fi
  else # efi directory(case don't care) exists
    efi_directory="$test_efi_directory"
    if [ "$verbose" = true ]; then
      printf -- \
        '%s: DEBUG: %s detected.\n' \
        "${FUNCNAME[0]}" \
        "$efi_directory"
    fi
  fi
  unset test_efi_directory

  typeset \
    test_efi_boot_directory \
    efi_boot_directory
  test_efi_boot_directory="$(
    find \
      "$target_fs_mountpoint" \
      -ipath "$efi_directory/boot"
  )"
  if [ -z "$test_efi_boot_directory" ]; then
    efi_boot_directory="$efi_directory/boot"
    if [ "$verbose" = true ]; then
      printf -- \
        "%s: DEBUG: Can't find efi/boot directory, use %s.\\n" \
        "${FUNCNAME[0]}" \
        "$efi_boot_directory"
    fi
  else # boot directory(case don't care) exists
    efi_boot_directory="$test_efi_boot_directory"
    if [ "$verbose" = true ]; then
      printf -- \
        '%s: DEBUG: %s detected.\n' \
        "${FUNCNAME[0]}" \
        "$efi_boot_directory"
    fi
  fi
  unset \
    efi_directory \
    test_efi_boot_directory

  # If there's already an EFI bootloader existed, skip the workaround
  typeset test_efi_bootloader
  test_efi_bootloader="$(
    find \
      "$target_fs_mountpoint" \
      -ipath "$target_fs_mountpoint/efi/boot/boot*.efi"
  )"
  if [ -n "$test_efi_bootloader" ]; then
    printf -- \
      'INFO: Detected existing EFI bootloader, workaround skipped.\n'
    return 0
  fi

  mkdir \
    --parents \
    "$efi_boot_directory"

  # Skip workaround if EFI bootloader already exist in efi_boot_directory
  7z \
    e \
    -so \
    "$source_fs_mountpoint/sources/install.wim" \
    "Windows/Boot/EFI/bootmgfw.efi" \
    >"$efi_boot_directory/bootx64.efi"
}
typeset -fr workaround_support_windows_7_uefi_boot

## Currently WoeUSB indirectly causes severely unresponsive system on 64-bit architecture with large primary memory during file copy process due to a flaw of the writeback buffer size handling in Linux kernel, workaround it before it is fixed
## Refer:
## - System lagging while copying data · Issue #113 · slacka/WoeUSB <https://github.com/slacka/WoeUSB/issues/113>
## - The pernicious USB-stick stall problem [LWN.net] <https://lwn.net/Articles/572911/>
workaround_linux_make_writeback_buffering_not_suck(){
  util_check_function_parameters_quantity 1 "${#}"
  typeset -r mode="${1}"

  typeset -ir VM_DIRTY_BACKGROUND_BYTES=$((16*1024*1024)) # 16MiB
  typeset -ir VM_DIRTY_BYTES=$((48*1024*1024)) # 48MiB

  case "${mode}" in
    apply)
      echo_with_color \
        yellow \
        'Applying workaround to prevent 64-bit systems with big primary memory from being unresponsive during copying files.'
      echo "${VM_DIRTY_BACKGROUND_BYTES}" > /proc/sys/vm/dirty_background_bytes
      echo "${VM_DIRTY_BYTES}" > /proc/sys/vm/dirty_bytes
      ;;
    reset)
      echo_with_color \
        yellow \
        'Resetting workaround to prevent 64-bit systems with big primary memory from being unresponsive during copying files.'

      { echo 0 > /proc/sys/vm/dirty_background_bytes; } || { echo_with_color yellow 'Warning!: command "echo 0 > /proc/sys/vm/dirty_background_bytes" - returned code  $?'; }
      { echo 0 > /proc/sys/vm/dirty_bytes; } || { echo_with_color yellow 'Warning: command "echo 0 > /proc/sys/vm/dirty_bytes" - returned code  $?'; }
      ;;
    *)
      printf_with_color \
        red \
        'Fatal: %s: Unexpected *mode* encountered, please report bug.\n' \
        "${FUNCNAME[0]}"
    ;;
  esac
}; typeset -fr workaround_linux_make_writeback_buffering_not_suck

install_legacy_pc_bootloader_grub(){
  util_check_function_parameters_quantity 3 "${#}"
  typeset -r target_fs_mountpoint="${1}"; shift 1
  typeset -r target_device="${1}"; shift 1
  typeset -r command_grubinstall="${1}"

  echo_with_color green 'Installing GRUB bootloader for legacy PC booting support...'
  "${command_grubinstall}" \
    --target=i386-pc \
    --boot-directory="${target_fs_mountpoint}" \
    --force "${target_device}"


}; typeset -fr install_legacy_pc_bootloader_grub

## Install a GRUB config file to chainload Microsoft Windows's bootloader in Legacy PC bootmode
## target_fs_mountpoint: Target filesystem's mountpoint(where GRUB is installed)
## name_grub_prefix: May be different between distributions, so need to be specified (grub/grub2)
install_legacy_pc_bootloader_grub_config() {
  util_check_function_parameters_quantity 2 $#

  typeset -r target_fs_mountpoint="$1"
  shift
  typeset -r name_grub_prefix="$1"

  echo_with_color green 'Installing custom GRUB config for legacy PC booting...'
  typeset -r grub_cfg="$target_fs_mountpoint/$name_grub_prefix/grub.cfg"
  typeset target_fs_uuid
  target_fs_uuid=$(
    lsblk \
      --noheadings \
      --raw \
      --output UUID,MOUNTPOINT |
      grep \
        --extended-regexp \
        "$target_fs_mountpoint"$ |
      cut \
        --fields=1 \
        --delimiter=' '
  )

  mkdir --parents "$(dirname "$grub_cfg")"
  {
    cat <<-END_OF_FILE
      ntldr /bootmgr
      boot
    END_OF_FILE
  } >"$grub_cfg"
  unset target_fs_uuid
}
typeset -fr install_legacy_pc_bootloader_grub_config

## Unmount mounted filesystem and clean-up mountpoint before exiting program
## return_value: 1 - Failed to unmount / 2 - Failed to remove mountpoint
cleanup_mountpoint() {
  util_check_function_parameters_quantity 2 "${#}"
  typeset -r fs_mountpoint="${1}"
  shift
  typeset -r only_for_gui="${1}"
  shift

  # In copy_filesystem_files, we use `pushd` to changed the working directory into source_fs_mountpoint in order to get proper source and target file path, proactively `popd` to ensure we are not in source_fs_mountpoint and preventing source filesystem to unmount
  popd &>/dev/null ||
    true

  if [ -e "$fs_mountpoint" ]; then
    printf_with_color \
      green \
      'Unmounting and removing "%s"...\n' \
      "$fs_mountpoint"
    if ! umount "$fs_mountpoint"; then
      printf_with_color \
        yellow \
        '%s: Warning: Unable to unmount "%s".\n' \
        "${FUNCNAME[0]}" \
        "$fs_mountpoint"
      return 1
    fi

    if ! rmdir "$fs_mountpoint"; then
      printf_with_color \
        yellow \
        '%s: Warning: Unable to remove "%s".\n' \
        "${FUNCNAME[0]}" \
        "$fs_mountpoint"
      return 2
    fi
  fi

  return 0
}
typeset -fr cleanup_mountpoint

## This function continuously moves the GUI creation dialog's progressing bar bit by bit, by running `echo pulse` every 0.05 seconds until the next call chooses to turn off
## Refer src/MainPanel.cpp MainPanel::OnInstall(wxCommandEvent& event) method for more info
## http://docs.wxwidgets.org/trunk/classwx_generic_progress_dialog.html#ab5ecf227eebaa1aadb5f5c553e4a4ee5
## switch: To enable or not enable this function(on/off)
trigger_wxGenericProgressDialog_pulse() {
  util_check_function_parameters_quantity 2 $#

  typeset switch="$1"
  shift
  typeset -r only_for_gui="$1"

  if [ "$only_for_gui" = false ]; then
    return 0
  fi

  case "$switch" in
    on)
      # Don't do anything if it is already turned on
      if [ "$pulse_current_pid" -ne 0 ]; then
        return 0
      fi

      while true; do
        sleep 0.05
        echo pulse
      done &
      pulse_current_pid="$!"
      disown
      ;;
    off)
      # Don't do anything if it is already turned off
      if [ "$pulse_current_pid" -eq 0 ]; then
        return 0
      fi

      kill "$pulse_current_pid"
      wait "$pulse_current_pid" 2>/dev/null || true
      pulse_current_pid=0
      ;;
    *)
      echo "${FUNCNAME[0]}: FATAL: Illegal parameter \"$1\"" >&2
      exit 1
      ;;
  esac
  return 0
}
typeset -fr trigger_wxGenericProgressDialog_pulse

## Traps: Functions that are triggered when certain condition occurred
## Shell Builtin Commands » Bourne Shell Builtins » trap
trap_errexit() {
  echo_with_color red "The command \"$BASH_COMMAND\" failed with exit status \"${?}\", program is prematurely aborted" 1>&2

  return 0
}
typeset -fr trap_errexit

trap_exit() {
  # Mountpoints aren't successfully removed
  typeset flag_unclean=false

  # Target filesystem failed to unmount
  typeset flag_unsafe=false

  # FIXME: Why `trigger_wxGenericProgressDialog_pulse off` here?
  trigger_wxGenericProgressDialog_pulse \
    off \
    "$global_only_for_gui"

  case "$current_state" in
    copying-filesystem | finished)
      workaround_linux_make_writeback_buffering_not_suck \
        reset
      ;;
  esac

  if util_is_parameter_set_and_not_empty \
    source_fs_mountpoint; then
    if ! cleanup_mountpoint \
      "$source_fs_mountpoint" \
      "$global_only_for_gui"; then
      flag_unclean=true
    fi
  fi

  if util_is_parameter_set_and_not_empty \
    target_fs_mountpoint; then
    if ! cleanup_mountpoint \
      "$target_fs_mountpoint" \
      "$global_only_for_gui"; then
      typeset -i return_value="${?}"

      flag_unclean=true

      if [ "$return_value" = 1 ]; then
        flag_unsafe=true
      fi
    fi
  fi

  if [ "$flag_unclean" = true ]; then
    echo_with_color \
      yellow \
      'Some mountpoints are not unmount/cleaned successfully and must be done manually'
  fi

  if [ "$flag_unsafe" = true ]; then
    echo_with_color \
      yellow \
      'We unable to unmount target filesystem for you, please make sure target filesystem is unmounted before detaching to prevent data corruption'
  fi

  unset \
    flag_unclean \
    flag_unsafe

  if
    util_is_parameter_set_and_not_empty target_device
  then
    if is_target_busy "$target_device"; then
      echo_with_color yellow 'Target device is busy, please make sure you unmount all filesystems on target device or shutdown the computer before detaching it.'
    else
      echo_with_color green 'You may now safely detach the target device'
    fi
  fi

  rm \
    --recursive \
    "$temp_directory"

  if [ "$current_state" = finished ]; then
    echo_with_color green 'Done :)'
    echo_with_color green 'The target device should be bootable now'
  fi

  return 0
}
typeset -fr trap_exit

trap_interrupt() {
  printf '\n' # Separate message with previous output
  echo_with_color yellow 'Recieved SIGINT, program is interrupted.' 1>&2
  return 1
}
typeset -fr trap_interrupt

trap_return() {
  util_check_function_parameters_quantity 1 "${#}"
  typeset returning_function="${1}"

  for ignored_function in \
    util_check_function_parameters_quantity \
    util_is_parameter_set_and_not_empty \
    switch_terminal_text_color \
    echo_with_color; do
    if [ "$returning_function" == "$ignored_function" ]; then
      return 0
    fi
  done

  echo_with_color green "${FUNCNAME[0]}: INFO: returning from $returning_function" 1>&2
}
typeset -fr trap_return

## FIXME: Debug trap never work as expected, it always
## prints two identical lines somehow.
trap_debug() {
  util_check_function_parameters_quantity 1 $#
  typeset -r command_to_be_executed="${1}"

  typeset -r command_base="${command_to_be_executed%% *}"

  for ignored_command in util_check_function_parameters_quantity util_is_parameter_set_and_not_empty echo_with_color switch_terminal_text_color tput printf_with_color; do
    if [ "$command_base" = "$ignored_command" ]; then
      return 0
    fi
  done

  case "$(type -t "$command_base")" in
    file)
      echo_with_color green "${FUNCNAME[0]}: INFO: Executing $command_to_be_executed"
      ;;
    function)
      echo_with_color green "${FUNCNAME[0]}: INFO: Calling $command_base"
      ;;
    *)
      :
      ;;
  esac

  return 0
}
typeset -fr trap_debug

## An utility function for inhibiting command call output and
## only show them to user when error occurred
util_call_external_command() {
  typeset -ar command=("${@}")

  typeset command_output
  typeset -i command_exit_status
  if command_output="$("${command[@]}" 2>&1)"; then
    command_exit_status=0
  else
    command_exit_status="$?"
  fi

  if [ "$command_exit_status" -ne 0 ]; then
    echo_with_color red "Error occurred while running command \"${command[*]}\" (exit status: $command_exit_status)!" >&2

    typeset -r read_prompt="Read command output (Y/n)?"
    printf '%s' "$read_prompt"

    typeset answer=y

    while true; do
      read -r answer

      if [ "$answer" == y ] || [ "$answer" == Y ]; then
        echo "$command_output"
        break
      elif [ "$answer" == n ] || [ "$answer" == N ]; then
        break
      else
        printf '%s' "$read_prompt"
      fi
    done

    echo_with_color red 'Press ENTER to continue' >&2
    read -r # catch enter key
  fi

  return "$command_exit_status"
}
typeset -fr util_call_external_command

## Configure the terminal to print future messages with certain color
## Parameters:
## - color: color of the next message, or `none` to reset to default color
util_switch_terminal_text_color() {
  util_check_function_parameters_quantity 1 $#
  typeset -r color="$1"

  case "$color" in
    black)
      echo -en '\033[0;30m'
      ;;
    red)
      echo -en '\033[0;31m'
      ;;
    green)
      echo -en '\033[0;32m'
      ;;
    yellow)
      echo -en '\033[0;33m'
      ;;
    blue)
      echo -en '\033[0;34m'
      ;;
    white)
      echo -en '\033[0;37m'
      ;;
    none)
      tput sgr0
      ;;
    *)
      printf -- \
        'Fatal: %s: Illegal parameter, please report bug.' \
        "${FUNCNAME[0]}" \
        1>&2
      exit 1
      ;;
  esac
}
typeset -fr util_switch_terminal_text_color

## Print message with color
util_echo_with_color() {
  util_check_function_parameters_quantity 2 "${#}"
  typeset -r message_color="${1}"
  shift
  typeset -r message_body="${1}"

  if [ "$no_color" = true ]; then
    echo -e "$message_body"
  else
    switch_terminal_text_color "$message_color"
    echo -e "$message_body"
    switch_terminal_text_color none
  fi
}
typeset -fr util_echo_with_color

## Print formatted message with color
util_printf_with_color() {
  if [ ${#} -lt 2 ]; then
    if [ "$no_color" == false ]; then
      switch_terminal_text_color red
    fi
    printf -- \
      'Fatal: %s: Parameter quantity illegal, please report bug.\n' \
      "${FUNCNAME[0]}"
    if [ "$no_color" == false ]; then
      switch_terminal_text_color none
    fi
    exit 1
  fi
  typeset -r color="${1}"
  shift
  typeset -ar printf_parameters=("${@}")

  if [ "$no_color" == true ]; then
    # False positive: not format string(ShellCheck #1028)
    # shellcheck disable=SC2059
    printf -- \
      "${printf_parameters[@]}"
  else # no_color = false
    switch_terminal_text_color "$color"
    # False positive: not format string(ShellCheck #1028)
    # shellcheck disable=SC2059
    printf -- \
      "${printf_parameters[@]}"
    switch_terminal_text_color none
  fi
}
typeset -fr util_printf_with_color

util_shift_array() {
  util_check_function_parameters_quantity 1 "${#}"

  typeset -n array_ref="${1}"

  if [ "${#array_ref[@]}" -eq 0 ]; then
    printf '%s: FATAL: array is empty!\n' "${FUNCNAME[0]}" 1>&2
    exit 1
  fi

  # Unset the 1st element
  unset 'array_ref[0]'

  # Repack array if element still available in array
  if [ "${#array_ref[@]}" -ne 0 ]; then
    array_ref=("${array_ref[@]}")
  fi

  return 0
}
typeset -fr util_shift_array

util_is_parameter_set_and_not_empty() {
  util_check_function_parameters_quantity 1 $#

  typeset parameter_name="${1}"

  if [ ! -v "$parameter_name" ]; then
    return 1
  else
    typeset -n parameter_ref
    parameter_ref="$parameter_name"

    if [ -z "$parameter_ref" ]; then
      return 1
    else
      return 0
    fi
  fi
}
typeset -fr util_is_parameter_set_and_not_empty

## Utility function to check if function parameters quantity is legal
## NOTE: non-static function parameter quantity(e.g. either 2 or 3) is not supported
util_check_function_parameters_quantity() {
  if [ "${#}" -ne 2 ]; then
    printf_with_color \
      red \
      '%s: FATAL: Function requires %u parameters, but %u is given\n' \
      "${FUNCNAME[0]}" \
      2 \
      "${#}"
    exit 1
  fi

  # The expected given quantity
  typeset -i expected_parameter_quantity="${1}"
  shift
  # The actual given parameter quantity, simply pass "${#}" will do
  typeset -i given_parameter_quantity="${1}"

  if [ "$given_parameter_quantity" -ne "$expected_parameter_quantity" ]; then
    printf_with_color \
      red \
      '%s: FATAL: Function requires %u parameters, but %u is given\n' \
      "${FUNCNAME[1]}" \
      "$expected_parameter_quantity" \
      "$given_parameter_quantity" \
      1>&2
    exit 1
  fi
  return 0
}
typeset -fr util_check_function_parameters_quantity

trap trap_exit EXIT
trap trap_errexit ERR
trap trap_interrupt INT

init \
  "$runtime_name" \
  global_only_for_gui
